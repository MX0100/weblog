name: ğŸš€ Deploy to Production

on:
  push:
    branches: [master]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment (dev/staging/prod)"
        required: false
        default: "dev"

env:
  # Global environment
  ENVIRONMENT: dev
  AWS_REGION: ${{ secrets.AWS_REGION || 'us-west-2' }}
  S3_BUCKET: ${{ secrets.S3_BUCKET }}
  CLOUDFRONT_DOMAIN: ${{ secrets.CLOUDFRONT_DOMAIN }}
  # Database and app secrets
  DB_HOST: ${{ secrets.DB_HOST }}
  DB_NAME: ${{ secrets.DB_NAME }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  JWT_SECRET: ${{ secrets.JWT_SECRET }}

jobs:
  # ======================================
  # Build and push backend Docker image
  # ======================================
  deploy-backend:
    name: â˜• Deploy Backend
    runs-on: ubuntu-latest

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: â˜• Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"

      - name: ğŸ—„ï¸ Cache Gradle packages
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ”‘ Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ—ï¸ Build and test backend
        working-directory: WeBlog_backend
        run: |
          chmod +x ./gradlew
          ./gradlew clean build -x test

      - name: ğŸ³ Build and push Docker image
        working-directory: WeBlog_backend
        run: |
          # Build multi-tag image
          docker build -f Dockerfile \
            -t mx0100/weblog-backend:latest \
            -t mx0100/weblog-backend:${{ github.sha }} \
            .

          # Push all tags
          docker push mx0100/weblog-backend:latest
          docker push mx0100/weblog-backend:${{ github.sha }}

      - name: ğŸ”„ Deploy to EC2 via SSM
        run: |
          echo "ğŸš€ Start deploying backend to EC2..."

          # Get EC2 instance ID (dev)
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=weblog-dev-web-server" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)

          echo "ğŸ“ Target instance: $INSTANCE_ID"

          if [ "$INSTANCE_ID" = "None" ] || [ -z "$INSTANCE_ID" ]; then
            echo "âŒ No matching EC2 instance (tag: weblog-dev-web-server)"
            exit 1
          fi

          # Use SSM to update docker-compose on EC2 and inject env vars
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo \"ğŸ”„ Start updating application...\"",
              "cd /opt/weblog",
              "echo \"ğŸ“ Generate standard docker-compose.prod.yml...\"",
              "bash -lc \"cat > docker-compose.prod.yml << 'EOF'\nversion: '3.8'\n\nservices:\n  weblog-backend:\n    image: mx0100/weblog-backend:latest\n    container_name: weblog-backend\n    ports:\n      - '8080:8080'\n    environment:\n      - SPRING_PROFILES_ACTIVE=prod\n      - DB_HOST=\\${DB_HOST}\n      - DB_NAME=\\${DB_NAME}\n      - DB_USERNAME=\\${DB_USERNAME}\n      - DB_PASSWORD=\\${DB_PASSWORD}\n      - JWT_SECRET=\\${JWT_SECRET}\n      - CORS_ORIGINS=\\${CORS_ORIGINS}\n      - JAVA_OPTS=-Xms256m -Xmx512m -Dspring.devtools.restart.enabled=false\n    restart: unless-stopped\n    healthcheck:\n      test: ['CMD', 'curl', '-f', 'http://localhost:8080/actuator/health']\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 60s\n    logging:\n      driver: 'awslogs'\n      options:\n        awslogs-group: '/aws/ec2/weblog-${{ env.ENVIRONMENT }}'\n        awslogs-region: '${{ env.AWS_REGION }}'\n        awslogs-stream: 'weblog-backend'\nEOF\"",
              "echo \"ğŸ”§ Set runtime environment variables...\"",
              "export DB_HOST=${{ env.DB_HOST }}",
              "export DB_NAME=${{ env.DB_NAME }}",
              "export DB_USERNAME=${{ env.DB_USERNAME }}",
              "export DB_PASSWORD=${{ env.DB_PASSWORD }}",
              "export JWT_SECRET=${{ env.JWT_SECRET }}",
              "export CORS_ORIGINS=https://${{ env.CLOUDFRONT_DOMAIN }}",
              "echo \"ğŸ“¥ Pull latest image...\"",
              "docker-compose -f docker-compose.prod.yml pull",
              "echo \"ğŸ”„ Restart application containers...\"",
              "docker-compose -f docker-compose.prod.yml up -d --force-recreate",
              "echo \"â³ Wait for application to start...\"",
              "sleep 30",
              "echo \"âœ… Application update completed\"",
              "docker ps | grep weblog-backend || true",
              "echo \"ğŸ” Check application logs...\"",
              "docker logs weblog-backend --tail 50 2>&1 || echo No logs available"
            ]' \
            --query "Command.CommandId" \
            --output text)

          echo "ğŸ“ Command ID: $COMMAND_ID"

          # Wait for command to complete
          echo "â³ Waiting for deployment to finish..."
          aws ssm wait command-executed \
            --command-id $COMMAND_ID \
            --instance-id $INSTANCE_ID

          # Get command output
          aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id $INSTANCE_ID \
            --query "StandardOutputContent" \
            --output text

          echo "ğŸ‰ Backend deployment completed!"

  # ======================================
  # Build and deploy frontend to S3
  # ======================================
  deploy-frontend:
    name: ğŸŒ Deploy Frontend
    runs-on: ubuntu-latest
    needs: deploy-backend
    # åªæœ‰åœ¨åç«¯éƒ¨ç½²æˆåŠŸæ—¶æ‰è¿è¡Œå‰ç«¯éƒ¨ç½²
    if: success()

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸŸ¢ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: WeBlog-frontend/package-lock.json

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ“¦ Install dependencies
        working-directory: WeBlog-frontend
        run: npm ci

      - name: ğŸ—ï¸ Build frontend
        working-directory: WeBlog-frontend
        env:
          VITE_API_BASE_URL: https://${{ env.CLOUDFRONT_DOMAIN }}
          VITE_WS_URL: wss://${{ env.CLOUDFRONT_DOMAIN }}/ws
          VITE_ENV_NAME: dev
        run: |
          echo "ğŸ—ï¸ Build frontend..."
          echo "API: $VITE_API_BASE_URL"
          echo "WebSocket: $VITE_WS_URL"
          npm run build

      - name: ğŸš€ Deploy to S3
        working-directory: WeBlog-frontend
        run: |
          echo "ğŸ“¤ Upload frontend assets to S3..."
          if [ -z "${{ env.S3_BUCKET }}" ]; then echo "âŒ S3_BUCKET secret is not set"; exit 1; fi
          aws s3 sync dist/ s3://${{ env.S3_BUCKET }}/ \
            --delete \
            --cache-control "public,max-age=31536000" \
            --exclude "*.html" \
            --exclude "*.json"

          # Sync HTML/JSON without cache
          aws s3 sync dist/ s3://${{ env.S3_BUCKET }}/ \
            --cache-control "no-cache" \
            --include "*.html" \
            --include "*.json"

          echo "âœ… Frontend files uploaded!"

      - name: ğŸ”„ Invalidate CloudFront cache
        run: |
          echo "ğŸ”„ Invalidate CloudFront cache..."
          if [ -z "${{ env.CLOUDFRONT_DOMAIN }}" ]; then echo "âŒ CLOUDFRONT_DOMAIN secret is not set"; exit 1; fi
          DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?DomainName=='${{ env.CLOUDFRONT_DOMAIN }}'].Id | [0]" \
            --output text)

          if [ "$DISTRIBUTION_ID" != "None" ] && [ "$DISTRIBUTION_ID" != "" ]; then
            INVALIDATION_ID=$(aws cloudfront create-invalidation \
              --distribution-id $DISTRIBUTION_ID \
              --paths "/*" \
              --query "Invalidation.Id" \
              --output text)
            
            echo "ğŸ”„ Invalidation ID: $INVALIDATION_ID"
            echo "âœ… CloudFront invalidation completed!"
          else
            echo "âš ï¸ CloudFront distribution not found"
          fi

  # ======================================
  # Health checks and validation
  # ======================================
  health-check:
    name: ğŸ” Health Check
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    # åªæœ‰åœ¨å‰ç«¯å’Œåç«¯éƒ½æˆåŠŸæ—¶æ‰è¿è¡Œå¥åº·æ£€æŸ¥
    if: success()

    steps:
      - name: â³ Wait for deployment stabilization
        run: |
          echo "â³ Wait for stabilization (60s)..."
          sleep 60

      - name: ğŸ” Check backend health
        run: |
          echo "ğŸ” Checking backend health..."
          BACKEND_URL="https://${{ env.CLOUDFRONT_DOMAIN }}/actuator/health"

          for i in {1..10}; do
            echo "ğŸ” Health check attempt $i/10..."
            
            if curl -f -s $BACKEND_URL | grep -q "UP"; then
              echo "âœ… Backend health check passed!"
              (curl -s $BACKEND_URL | jq '.' ) || curl -s $BACKEND_URL || true
              break
            fi
            
            if [ $i -eq 10 ]; then
              echo "âŒ Backend health check failed"
              exit 1
            fi
            
            echo "â³ Retry after 30s..."
            sleep 30
          done

      - name: ğŸ” Check frontend accessibility
        run: |
          echo "ğŸ” Checking frontend accessibility..."
          FRONTEND_URL="https://${{ env.CLOUDFRONT_DOMAIN }}"

          if curl -f -s $FRONTEND_URL > /dev/null; then
            echo "âœ… Frontend is accessible!"
            echo "ğŸŒ Frontend URL: $FRONTEND_URL"
          else
            echo "âŒ Frontend access failed"
            exit 1
          fi

      - name: ğŸ‰ Deployment summary
        run: |
          echo "ğŸ‰ Deployment summary:"
          echo "================================"
          echo "ğŸŒ Frontend: https://${{ env.CLOUDFRONT_DOMAIN }}"
          echo "ğŸ”§ Backend API: https://${{ env.CLOUDFRONT_DOMAIN }}/api"
          echo "ğŸ’“ Health: https://${{ env.CLOUDFRONT_DOMAIN }}/actuator/health"
          echo "ğŸ”Œ WebSocket: wss://${{ env.CLOUDFRONT_DOMAIN }}/ws/notifications"
          echo "ğŸš€ éƒ¨ç½²æ—¶é—´: $(date)"
          echo "ğŸ“ Gitæäº¤: ${{ github.sha }}"
          echo "================================"
          echo "âœ… All services are running!"

  # ======================================
  # Notification (optional)
  # ======================================
  notify:
    name: ğŸ“¢ Notification
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend, health-check]
    if: always()

    steps:
      - name: ğŸ“¢ Deployment notification
        run: |
          # Summarize job results
          BACKEND_STATUS="${{ needs.deploy-backend.result }}"
          FRONTEND_STATUS="${{ needs.deploy-frontend.result }}"
          HEALTH_STATUS="${{ needs.health-check.result }}"

          echo "ğŸ” Deployment results:"
          echo "Backend: $BACKEND_STATUS"
          echo "Frontend: $FRONTEND_STATUS"  
          echo "Health: $HEALTH_STATUS"

          # å¦‚æœæ‰€æœ‰å…³é”®æ­¥éª¤éƒ½æˆåŠŸ
          if [ "$BACKEND_STATUS" == "success" ] && [ "$FRONTEND_STATUS" == "success" ] && [ "$HEALTH_STATUS" == "success" ]; then
            echo "ğŸ‰ Deployment succeeded!"
            echo "ğŸŒ URL: https://${{ env.CLOUDFRONT_DOMAIN }}"
            echo "â° Time: $(date)"
            echo "ğŸ“ Commit: ${{ github.sha }}"
          else
            echo "âŒ Deployment failed:"
            echo "  - Backend: $BACKEND_STATUS"
            echo "  - Frontend: $FRONTEND_STATUS"
            echo "  - Health: $HEALTH_STATUS"
            echo ""
            echo "Please check logs for failed steps"
            exit 1
          fi
